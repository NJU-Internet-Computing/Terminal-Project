<h1 style="text-align:center;">第三组微信小程序开发文档</h1>



[toc]

## 成员介绍与分工

| 姓名   | 学号      | 分工                                                         |
| ------ | --------- | ------------------------------------------------------------ |
| 侯雨希 | 191250046 | 主要负责数独游戏基础功能的实现                               |
| 郭瀚宇 | 191250039 | 负责数独游戏界面的美化与功能完善                             |
| 刘伊眉 | 191250094 | 负责小程序部分界面的实现以及整个小程序的艺术风格             |
| 樊言鹏 | 191250028 | 负责正常模式、拼图模式的数独数据设计及生成，以及开发云的数据存储 |
| 李泳霆 | 191250076 | 负责正常模式、拼图模式的数独数据设计，部分文档编写           |



## 文档修改历史

| 时间          | 姓名   | 备注                           |
| ------------- | ------ | ------------------------------ |
| 2021年6月13日 | 侯雨希 | 初始化文档以及项目详情         |
| 2021年6月13日 | 李泳霆 | 补充了文档"数组生成"部分       |
| 2021年6月16日 | 樊言鹏 | 完善数独生成，添加数据交互部分 |
|               |        |                                |



## 项目地址

Github项目地址：https://github.com/NJU-Internet-Computing/Terminal-Proect



Github项目下载url：

* HTTPS：https://github.com/NJU-Internet-Computing/Terminal-Proect.git
* SSH：git@github.com:NJU-Internet-Computing/Terminal-Project.git



## 项目详情

### 首页界面

<img src="" alt="首页的图片">

### 正常模式

#### 难度选择

<img src="" alt="选择难度的图片">

#### 游玩界面

#####  界面概述

<img src="" alt="刚进入正常模式的图片">

1. 界面正中间是一个常见的数独的盘面。盘面按照九宫格的形式划分成9个较小的宫格，这9个宫格又分别按照九宫格形式分为9个格子，故一共是九九八十一个格子。数独开局时，其中一些格子上已经填上了数字，这些数字是完成该局数独的系统提示，这些格子不可被玩家选中，格子上的数字也不可被改变。剩余的空各自可以被玩家选中并填上数字。
2. 数独盘面的上方有两个按钮，左上角的是全部清空按钮，右上角是显示候选按钮。
3. 数独盘面的下方有三个按钮，左下角的是撤销按钮，右下角是撤回按钮，正下方的是清空按钮。
4. 这三个按钮下方是数字选择器，用于在选中的格子中填入数字

##### 游玩正常流程

玩家进行数独游戏的正常流程：

1. 玩家选择一个格子
2. 该格子被突出显示表明被选中，且界面下方出现数字选择器
3. 玩家在数字选择器中选择一个数字
4. 被选中的格子被填入选择的数字
5. 如果此时整个数独盘面满足数独通关的规则，即盘面的每一行、每一列、每个宫格都恰好包含1~9九个数字，则提示玩家游戏通关
6. 重复步骤1~5，直至玩家通关该局数独，或者玩家选择中断该局数独

##### 清空与全部清空

* 清空按钮
  1. 玩家选中某格子，
  2. 该格子被突出显示表明被选中
  3. 玩家选择清空
  4. 格子中填入数字被清除，此时格子被清空

* 全部清空按钮
  1. 玩家选择全部清空
  2. 所有玩家填入的数字被清空，只剩下开局时系统提供的数字



##### 撤销与撤回

* 撤销，
  1. 玩家执行了某步操作，包括：选择某个格子、填入数字、清空某格子、或者进行全部清空；玩家选择撤销
  2. 盘面回到玩家执行该步操作之前的状态
  3. 玩家可以连续撤销多次
  4. 盘面回到玩家执行相应次数操作之前的状态
* 撤回
  1. 玩家选择撤销后，选择撤回
  2. 盘面回到玩家执行该步操作之后的状态
  3. 玩家可以多次撤回
  4. 盘面回到玩家执行相应次数撤销之前的状态

##### 显示候选

某个格子的候选数定义为该格子所在的行、列、宫格中没有出现过的，且在1~9之中的数字

1. 玩家选择显示候选
2. 按钮上的文字更改为隐藏候选。没有被填入数字的格子会进一步划分成9个小格子，分别对应着1~9这九个数字。该格子的所有候选数会显示在对应的小格子中。
3. 玩家选择某个格子，填入一个新的数字
4. 该格子所在的行、列、宫格中的每个格子的候选数可能发生变化，这些格子的小格子显示的候选数也会实时更新
5. 玩家选择隐藏候选
6. 盘面上所有候选数字消失

##### 数字选择器

数独的八十一个格子分别对应一个数字选择器，数字选择器每次都显示1~9这九个数字，但有一部分数字不可选，因此每个格子不可选的数字都不一样。该部分数字即选择器对应的格子所在的行、列、宫格包含的所有格子在开局时已经填上的数字。

1. 玩家在数字选择器中选择一个数字
2. 该数字周围出现一个提示框，表明该数字被选中
3. 玩家选择另外一个数字
4. 提示框移动到该数字，表明新的数字被选中
5. 玩家选择显示候选
6. 数字选择器中属于该格子候选数的数字的右上角出现一个绿色提示点，提示该数字是候选数，此时选择器中有绿色提示点的数字与格子中的候选数一一对应。非候选数没有变化。被选中的数字没有提示点
7. 玩家双击有绿色提示点的候选数
8. 绿色提示点变为橙色提示点，提示该数字不再作为该格子的候选数，此时格子中显示的候选数不包含该数字
9. 玩家再次双击橙色提示点的数字
10. 提示点变回绿色，格子中再次显示该候选数



### 拼图模式

#### 游玩界面

##### 界面概述

1. 正中间是一个数独盘面，与正常模式的基本一致。开局时，将会有一个宫格的格子全空，且其余给你宫格的格子非空
2. 盘面正下方是一个方向选择器，有上下左右四个方向的箭头，分别表示选择这四个方向。

##### 游玩正常流程

通关规则：

* 每行、列、宫格，如果不包含空宫格中的格子，则需要恰好包含1~9九个数字
* 如果包含空宫格中的格子，则剩余的格子不能有重复数字



正常流程：

1. 玩家选择一个方向，比如上
2. 空宫格的下方的宫格将会与空宫格交换位置
3. 如果盘面满足通关规则，则提示玩家通关





### 数独生成

#### 1. 获得未挖空数独原表

1. 初始化 9X9 二维数组，将每个位置修改为默认值0。

2. 对于二维数组进行循环数值插入，对于每行，每列，每宫已经存在的数字进行去重获得可选数字列表，随机选取可选数字填入，若表未填满而可选数字为空，回到1状态。

3. 每个循环中若最终遍历完表格能够填满则成功，存入数组集合中；重复执行1~2。

4. 将成功生成的数独原表存储为json文件。

   效果：

   ​		我们组生成了超过一千张原表，为后序难度梯度划分提供数据量的基础。

**数独原表生成效果图：**

![image-20210615232904158](https://fan-day.oss-cn-shanghai.aliyuncs.com/SE/1/image-20210615232904158.png)



#### 2. 正常模式

##### **挖空算法**：随机挖空+唯一性检验

随机挖空：生成随机数，将数独表的某一非0位置置为0，执行唯一性检验；若挖空后数独表有两种填入方式，即可确定唯一性检验失败，复原该位置；若成功，继续挖空直到达到目标空格数目。

唯一性检验：数独的唯一性检验使用了回溯算法，递归填写数独。若数独填写过程中遇到填写异常（当前位置没有可填入的数值），即退回当前操作，恢复操作前状态。直至数独填写完成。因为数独本身拥有原表中的解法，所以当解数独过程中出现了结果与原数读不同，即认为数独结果不唯一性，返回false。

##### 算法优化

​		由于数独挖空算法的时间复杂度随挖空数量增加而非线性增加，当挖空数目较大时程序的运行时间受到极大影响，难以在可接受时间内生成较为复杂的数独表。

​		为了提高多空格数独生成速度，我们尝试应用了回溯算法中的“剪枝”思想，即在唯一性检验过程中，每一次都选取可填写选择最小的方块开始填写。

<img src="https://fan-day.oss-cn-shanghai.aliyuncs.com/SE/1/98119ECF3F6F5A0380422FEF13FA8012.jpg" alt="img" style="zoom: 50%;" />

​		例如上图，若直接进行回溯，会从左上角第一个空格开始填入，这样的话在每一层都会产生更多的分支。而在对算法进行优化后，我们每一步填入数值时都选择可选数目最小的空格进行填入，这样能大大减少求解过程中没有意义的分支，最终挖空算法消耗时间相对理想：

```
//数独81个空，保证唯一解的理论挖空上限为64个
//算法优化后一次随机生成数独表的耗时
//数独表生成本身是随机的，耗时不呈现严格单调规律，但总体上当挖空数目增加后，数独生成会大幅度变慢

数独表挖空（保证唯一解） 40 个，共花费 0.03500 秒
数独表挖空（保证唯一解） 41 个，共花费 0.04407 秒
数独表挖空（保证唯一解） 42 个，共花费 0.04593 秒
数独表挖空（保证唯一解） 43 个，共花费 0.05608 秒
数独表挖空（保证唯一解） 44 个，共花费 0.05493 秒
数独表挖空（保证唯一解） 45 个，共花费 0.06101 秒
数独表挖空（保证唯一解） 46 个，共花费 0.06107 秒
数独表挖空（保证唯一解） 47 个，共花费 0.06900 秒
数独表挖空（保证唯一解） 48 个，共花费 0.11491 秒
数独表挖空（保证唯一解） 49 个，共花费 0.10000 秒
数独表挖空（保证唯一解） 50 个，共花费 0.09005 秒
数独表挖空（保证唯一解） 51 个，共花费 0.12395 秒
数独表挖空（保证唯一解） 52 个，共花费 0.16300 秒
数独表挖空（保证唯一解） 53 个，共花费 0.17909 秒
数独表挖空（保证唯一解） 54 个，共花费 0.26899 秒
数独表挖空（保证唯一解） 55 个，共花费 0.46992 秒
数独表挖空（保证唯一解） 56 个，共花费 0.98808 秒
数独表挖空（保证唯一解） 57 个，共花费 0.27600 秒
数独表挖空（保证唯一解） 58 个，共花费 0.47210 秒
数独表挖空（保证唯一解） 59 个，共花费 2.68098 秒
```



##### 生成数独

​		运用优化后的数独生成算法，结合数独难度初步判断，我们选取生成了空数在[40,60）的共计20*20共400张数独表，将其以json文件存储。



##### 划分难度

​		关于数独难度的分析，我们参考[数独游戏的难度等级分析及求解算法研究2——数独难度等级](https://www.cnblogs.com/candyhuang/archive/2011/08/25/2153668.html)中自由度的定义，重新定义了单纯依赖由空格自由度定义的复杂度（统计数独表在空格所在行、所在列、所在宫格中的空格数量之和）。在导入400张数独表，经过空格自由度计算后，我们得到了如下由空格自由度定义的难度分布：

```
//“*”表示在该区间的数独表数目
[ 300 , 350 )	:  
[ 350 , 400 )	:  ***
[ 400 , 450 )	:  *********************
[ 450 , 500 )	:  ************************************
[ 500 , 550 )	:  **********************************************
[ 550 , 600 )	:  ***********************************
[ 600 , 650 )	:  ****************************************
[ 650 , 700 )	:  ***********************************
[ 700 , 750 )	:  *******************************************
[ 750 , 800 )	:  *****************************
[ 800 , 850 )	:  *************************************
[ 850 , 900 )	:  *********************************
[ 900 , 950 )	:  **************************
[ 950 , 1000 )	:  ****************
[ 1000 , 1050 )	:  
```

​		之后我们通过复杂度定义1:2:1的复杂度定位，对应小程序“简单”，“普通”，“困难”三档难度，并将数独表填上复杂度后存入json文件。



#### 3.拼图模式

##### 随机换位

​		拼图模式没有难度的考虑，我们直接进行了拼图数独表的生成并存入json文件。

​		初始化挖去原数独表一个宫格的数字，然后随机交换为空的宫格和其他宫格的位置，重复若干次之后得到一个随机结果（为了保证PUZZLE模式的随机性，我们进行10000次随机交换），将结果做持久化处理。



### 数据交互

##### 云函数

​		我们组使用了云开发，在阿里云上部署了云函数，提供了getSudoku方法，根据http协议完成数据请求。

​		函数请求url：https://bad254f1-21d0-47f0-a947-39505455c903.bspapp.com/http/getSudoku，返回json格式下的数独表，请求参数包括mode, difficulty

​		对于正常模式（“NORMAL”），云函数继续接收难度参数，然后经过逻辑运算后产生对应难度随机id值，并以唯一的id访问云数据库，返回前端所需数独表。

​		对于拼图模式（“PUZZLE”），云函数随机生成数独id直接读取对应云数据库。

```
//返回数据格式示例：
[[8,9,0,1,3,0,0,0,0],[7,4,2,6,8,0,0,3,9],[3,5,0,0,0,0,2,8,6],[0,0,3,7,0,0,9,5,0],[0,1,0,5,0,0,3,7,8],[0,0,0,9,0,0,0,0,4],[0,0,5,0,0,4,0,0,3],[0,3,9,0,0,0,0,6,7],[0,0,0,0,7,0,0,1,2]]
```

##### 云数据库

​		我们组的数独数据以json数据库的形式存储在uniCloud，如图：

![image-20210616011711327](https://fan-day.oss-cn-shanghai.aliyuncs.com/SE/1/image-20210616011711327.png)

​		前端通过云函数获取数据库中的数据，我们在云函数中提前预设了id与难度的对应关系，因此在获取数据表的时候仅根据id获得返回值，而不是返回同一难度的所有json对象，数据库数据请求量大大减少。

​		云函数中调用云数据库的方法：

```javascript
//puzzle模式下的数据库访问：
		const db = uniCloud.database();
		// 获取 `sudoku` 集合的引用

		const sudoku = db.collection('sudokuPuzzle');
		// const dbCmd = db.command ;

		let id = getRndInteger(1,101);//确定返回数独表id

		//由id获取数据库返回值
		let result = await sudoku.where({
			_id: id      
		}).get();
```

























